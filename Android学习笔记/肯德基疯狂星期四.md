#  **KFC疯狂星期四**



## 1.探究Activity

### 在Activity中使用Toast

```kotlin
val button3 = findViewById<Button>(R.id.button3)
        button3.setOnClickListener {
            Toast.makeText(this, "ThirdActivity", Toast.LENGTH_SHORT).show()
        }
```

### ViewBinding的使用

1. 在`build.gradle.kts`导入`ViewBinding`
2. 在活动中导入自动生成的 `ViewBinding `类并对其进行声明(根据活动)
3. 绑定布局

```kotlin
android {
    // 启用 ViewBinding
    viewBinding {
        enable = true
    }
}
```

```kotlin
import com.example.activitytest.databinding.FirstLayoutBinding  // 自动生成的 ViewBinding 类(根据该活动)

class FirstActivity : BaseActivity() {
    private lateinit var binding: FirstLayoutBinding  // 声明 ViewBinding 变量
    private val TAG = "FirstActivity"

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.d(TAG, "Task id is $taskId")
        // 绑定布局
        binding = FirstLayoutBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // 设置按钮点击事件
        binding.button1.setOnClickListener {
          
        }
    }
```



### 在活动中使用Menu

1. 在`res`目录下新建`menu`文件夹并生成`main`文件
2. 在活动中重写`onCreateOptionsMenu()`方法与`onOptionsItemSelected()`方法
3. 修改主题

```kotlin
override fun onCreateOptionsMenu(menu: Menu?): Boolean {
        menuInflater.inflate(R.menu.main, menu)
        return true
    }
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.add_item -> Toast.makeText(this, "You clicked Add", Toast.LENGTH_SHORT).show()
            R.id.remove_item -> Toast.makeText(this, "You clicked Remove", Toast.LENGTH_SHORT).show()
        }
        return true
    }
```

```kotlin
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.ActivityTest" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">#FDD3E1</item>
        <item name="colorPrimaryVariant">#EBB7C9</item>
        <item name="colorOnPrimary">#F8EBEF</item>
        <!-- Secondary brand color. -->
        <item name="colorSecondary">#E2B5C4</item>
        <item name="colorSecondaryVariant">#F29AB8</item>
        <item name="colorOnSecondary">#D95D88</item>
        <!-- Status bar color. -->
        <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
        <!-- Customize your theme here. -->
    </style>
</resources>
```



### 使用Intent在Activity之间穿梭

#### 显式Intent

```kotlin
binding.button1.setOnClickListener {
           val intent = Intent(this, SecondActivity::class.java)
           startActivity(intent)
        }
```



#### 隐式Intent(指定对应action和category等信息去响应)

1. 指定当前`Activity`能够响应的`action`和`category`
2. 调用`addCategory()`方法添加一个category

```kotlin
<activity
            android:name=".SecondActivity"
            android:launchMode="singleInstance"
            android:exported="false">
            <intent-filter>
                <action android:name="com.example.activitytest.ACTION_START" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="com.example.activitytest.MY_CATEGORY" />
            </intent-filter>
        </activity>
```

```kotlin
 binding.button1.setOnClickListener {
           val intent = Intent("com.example.activitytest.ACTION_START")
           intent.addCategory("com.example.activitytest.MY_CATEGORY")
           startActivity(intent)
        }
    }
```

**打开百度**

```kotlin
 binding.button1.setOnClickListener {
           val intent = Intent(Intent.ACTION_VIEW)
           intent.data = Uri.parse("https://www.baidu.com")
           startActivity(intent)
        }
    }
```

**打开电话**

```kotlin
binding.button1.setOnClickListener {
           val intent = Intent(Intent.ACTION_DIAL)
           intent.data = Uri.parse("tel:10086")
           startActivity(intent)
        }
    }
```



#### 向下一个Activity传递数据

运用`putExtra()`方法的重载

```kotlin
binding.button1.setOnClickListener {
           val data = "Hello SecondActivity"
           val intent = Intent(this, SecondActivity::class.java)
           intent.putExtra("extra_data", data) // 第一个参数是键,第二个是要传递的数据
           startActivity(intent)
        }
    }
```

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.second_layout)
        val extraData = intent.getStringExtra("extra_data")
    }

```



#### 返回数据给上一个Activity

1. 用`startActivityForResult()`启动活动
2. 用`setResult()`方法向上一个Activity返回数据
3. 在上一个活动重写`onActivityResult`方法

```kotlin
binding.button1.setOnClickListener {
           val intent = Intent(this, SecondActivity::class.java)
           startActivityForResult(intent, 1) // 第二个是请求码
        }
    }
```

```kotlin
class SecondActivity : AppCompatActivity() {
    private lateinit var binding: SecondActivityBinding  // 使用生成的绑定类
    private val TAG = "SecondActivity"

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.d(TAG, "Task id is $taskId")
        // 绑定布局
        binding = SecondActivityBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // 使用 binding.button2 访问视图（确保在布局中存在 id 为 button2 的控件）
        binding.button2.setOnClickListener {
           val intent = Intent().apply {
                putExtra("data_return", "Hello FirstActivity")
            }
            setResult(RESULT_OK, intent)
            finish()
        }
    }
```

```kotlin
override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    // 首先调用父类的onActivityResult方法，确保默认行为得到执行
    super.onActivityResult(requestCode, resultCode, data)
    
    // 根据requestCode判断是哪个Activity返回的结果
    when (requestCode) {
        // requestCode为1时，表示是特定的Activity返回结果
        1 -> {
            // 如果返回结果为成功（RESULT_OK）
            if (resultCode == RESULT_OK) {
                // 从Intent中获取返回的字符串数据，key为"data_return"
                val returnedData = data?.getStringExtra("data_return")
                
                // 使用Log.d输出日志，打印返回的数据，TAG为类标识
                Log.d(TAG, "returned data is $returnedData")
            }
        }
    }
}
```



### Activity的生命周期

#### 1. onCreate()

- 作用

  ：当 Activity 第一次被创建时调用。在这个方法中，你通常会完成以下工作：

  - 设置布局文件（例如调用 `setContentView()`）
  - 初始化控件、变量和数据
  - 配置基本组件（如 Toolbar、Fragment 等）

- 示例代码

  ```kotlin
  override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState)
      setContentView(R.layout.activity_main)
      // 初始化操作
  }
  ```

#### 2. onStart()

- **作用**：在 `onCreate()` 之后调用，此时 Activity 已经对用户可见，但还未获得焦点，也就是还不能进行用户交互。通常在这里启动一些即将进入前台的操作。

- 示例代码

  ```kotlin
  override fun onStart() {
      super.onStart()
      // Activity 对用户可见，但尚未获得焦点
  }
  ```

#### 3. onResume()

- **作用**：在 `onStart()` 之后调用，此时 Activity 已经位于前台，并且可以接收用户的输入和交互。这也是应用处于“运行”状态的主要阶段。

- 示例代码

  ```kotlin
  override fun onResume() {
      super.onResume()
      // 开始处理用户交互，如启动动画、注册传感器等
  }
  ```

#### 4. onPause()

- **作用**：当系统准备启动或恢复另一个 Activity 时调用，此时当前 Activity 仍然部分可见，但失去了用户焦点。通常在这里进行轻量级的保存工作，比如暂停动画、保存数据或释放一些占用较多资源的操作。

- **注意**：此方法的执行时间应该尽可能短，以免阻塞其他 Activity 的启动。

- 示例代码

  ```kotlin
  override fun onPause() {
      super.onPause()
      // 暂停动画、保存数据、释放资源等
  }
  ```

#### 5. onStop()

- **作用**：当 Activity 完全对用户不可见时调用，可能是因为新的 Activity 覆盖在上面或 Activity 被销毁。通常在这里释放不再需要的资源，并执行较重的保存工作。

- 示例代码

  ```kotlin
  override fun onStop() {
      super.onStop()
      // 释放资源、保存数据等
  }
  ```

#### 6. onDestroy()

- **作用**：在 Activity 被完全销毁之前调用。这可能是因为用户主动关闭 Activity 或系统由于资源不足而销毁 Activity。在此方法中需要清理所有占用的资源，确保内存没有泄漏。

- 示例代码

  ```kotlin
  override fun onDestroy() {
      super.onDestroy()
      // 清理资源、取消注册监听器等
  }
  ```

#### 7. onRestart()

- **作用**：当一个已停止的 Activity 将要重新启动时调用，此方法紧接在 `onStop()` 之后调用，然后进入 `onStart()`。常用于重新初始化在 `onStop()` 中释放的资源或状态恢复。

- 示例代码

  ```kotlin
  override fun onRestart() {
      super.onRestart()
      // 准备 Activity 重新对用户可见
  }
  ```

#### 生命周期的常见调用顺序

- **初次启动 Activity**：
   `onCreate()` → `onStart()` → `onResume()`
- **用户离开 Activity（例如启动另一个 Activity 或按下 Home 键）**：
   `onPause()` → `onStop()`
- **用户返回到 Activity**：
   `onRestart()` → `onStart()` → `onResume()`
- **销毁 Activity**：
   `onPause()` → `onStop()` → `onDestroy()`



### 如果Activity被回收了怎么办

1. 使用`onSaveInstanceState`回调方法保存数据
2. 在`onCreate()`方法里面对其进行恢复

```kotlin
class MainActivity : AppCompatActivity() {

    // 定义一个需要保存的变量
    private var counter: Int = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 如果 savedInstanceState 不为 null，则恢复数据
        savedInstanceState?.let {
            counter = it.getInt("counter_key", 0)
        }

        // 其他初始化代码
    }

    // 在此回调中保存需要持久化的数据
    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        // 将 counter 的值存入 Bundle 中
        outState.putInt("counter_key", counter)
    }
}

```



### Activity的启动方式

#### 1. AndroidManifest.xml 配置

在 `AndroidManifest.xml` 中，为每个 Activity 配置不同的启动模式：

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.launchmode">

    <application
        android:allowBackup="true"
        android:label="@string/app_name"
        android:theme="@style/AppTheme">

        <!-- Standard 模式：每次启动都会创建一个新实例 -->
        <activity
            android:name=".StandardActivity"
            android:launchMode="standard">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!-- SingleTop 模式：如果该 Activity 已经处于任务栈顶部，则复用当前实例，
             否则创建新实例 -->
        <activity
            android:name=".SingleTopActivity"
            android:launchMode="singleTop">
        </activity>

        <!-- SingleTask 模式：系统保证全局只有一个该 Activity 实例，
             如果已存在，则清除它之上的 Activity，并通过 onNewIntent() 传递新的 Intent -->
        <activity
            android:name=".SingleTaskActivity"
            android:launchMode="singleTask">
        </activity>

        <!-- SingleInstance 模式：该 Activity 独占一个任务栈，
             栈中只有它自己，其他 Activity 将在其它任务栈中运行 -->
        <activity
            android:name=".SingleInstanceActivity"
            android:launchMode="singleInstance">
        </activity>

    </application>
</manifest>
```



#### 2. Kotlin 代码示例与注释

##### (1) StandardActivity

**说明**：Standard 模式是 Android 的默认模式，每次启动该 Activity 都会新建一个实例，即使之前已有相同类型的 Activity 存在于任务栈中。

```kotlin
/**
 * StandardActivity 使用 standard 模式，
 * 每次启动都会创建一个新的实例。
 */
class StandardActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_standard)
        // 此处执行初始化工作，每次启动该 Activity 都是一个全新的状态
    }
}
```

------

##### (2) SingleTopActivity

**说明**：SingleTop 模式下，如果目标 Activity 已经处于任务栈的顶部，则不会创建新的实例，而是调用 onNewIntent() 方法传递新的 Intent；如果不在栈顶，则会创建新实例。

```kotlin
/**
 * SingleTopActivity 使用 singleTop 模式，
 * 当该 Activity 已经在任务栈顶部时，新的启动请求不会创建新实例，
 * 而是通过 onNewIntent() 方法传递新的 Intent。
 */
class SingleTopActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_single_top)
        // 初始化工作
    }

    /**
     * 当 SingleTopActivity 已经在任务栈顶部时，
     * 再次启动该 Activity 会调用此方法，传入新的 Intent。
     */
    override fun onNewIntent(intent: Intent?) {
        super.onNewIntent(intent)
        // 处理新的 Intent，例如更新界面数据或状态
    }
}
```

------

##### (3) SingleTaskActivity

**说明**：SingleTask 模式确保在系统中只存在一个该 Activity 的实例。当再次启动时，如果实例已存在，系统会将其上面的所有 Activity 清除，并调用 onNewIntent() 方法传递 Intent。

```kotlin
/**
 * SingleTaskActivity 使用 singleTask 模式，
 * 系统中全局只有一个该 Activity 的实例。
 * 如果该实例已存在，再次启动时会清除它之上的所有 Activity，
 * 并通过 onNewIntent() 传递新的启动 Intent。
 */
class SingleTaskActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_single_task)
        // 初始化代码
    }

    /**
     * 当 SingleTaskActivity 已存在且收到新的启动请求时，
     * 系统会调用此方法，并传递新的 Intent。
     */
    override fun onNewIntent(intent: Intent?) {
        super.onNewIntent(intent)
        // 处理新的 Intent，例如刷新界面或更新数据
    }
}
```

------

##### (4) SingleInstanceActivity

**说明**：SingleInstance 模式是最严格的启动模式，该 Activity 所在的任务栈中只允许存在它本身，其它 Activity 会在其他任务栈中运行，从而实现高度隔离。

```kotlin
/**
 * SingleInstanceActivity 使用 singleInstance 模式，
 * 该模式下，该 Activity 独占一个任务栈，
 * 任务栈中只包含它自己，其他 Activity 将不会进入此任务栈。
 */
class SingleInstanceActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_single_instance)
        // 初始化代码
    }
}
```

------

#### 3. 总结

- **standard**
   每次启动时都会创建新的 Activity 实例，适用于不需要保留之前状态的场景。
- **singleTop**
   如果目标 Activity 已位于任务栈顶部，则复用实例（调用 onNewIntent()），否则创建新实例。适合频繁接收新 Intent 的场景。
- **singleTask**
   保证全局只有一个实例，启动时会清除目标实例之上的所有 Activity，并调用 onNewIntent()。适用于需要全局唯一实例的核心界面。
- **singleInstance**
   该 Activity 独占任务栈，其他 Activity 不会与其共存。适用于需要高度隔离的场景，如系统级界面或特殊业务场景。



### Activity的最佳实践

#### 知晓当前是在哪一个活动

```kotlin
open class BaseActivity : AppCompatActivity(){
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.d("BaseActivity", javaClass.simpleName)
    }
}
```



#### 随时随地退出程序

```kotlin
package com.example.activitytest

import android.app.Activity

object ActivityCollector {
    private val activities = ArrayList<Activity>()
    fun addActivity(activity: Activity) {
        activities.add(activity)
    }
    fun removeActivity(activity: Activity) {
        activities.remove(activity)
    }
    fun finishAll() {
        for (activity in activities) {
            if (!activity.isFinishing) {
                activity.finish()
            }
        }
        activities.clear()
    }
}
```

```kotlin
open class BaseActivity : AppCompatActivity(){
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.d("BaseActivity", javaClass.simpleName)
        ActivityCollector.addActivity(this)
    }
    override fun onDestroy() {
        super.onDestroy()
        ActivityCollector.removeActivity(this)
    }
}
```

```kotlin
val button3 = findViewById<Button>(R.id.button3)
        button3.setOnClickListener {
            ActivityCollector.finishAll()
            android.os.Process.killProcess(android.os.Process.myPid())
        }
```



#### 启动Activity的最佳写法

```kotlin
// 在要启动的活动内添加该静态方法

companion object {
    // 封装启动 SecondActivity 的静态方法
    fun actionStart(context: Context, data: String) {
        // 创建一个 Intent 对象，指定从当前上下文启动 SecondActivity
        val intent = Intent(context, SecondActivity::class.java)
        // 将传入的字符串数据作为额外参数存入 Intent，
        // "extra_data" 为键，用于在 SecondActivity 中提取该数据
        intent.putExtra("extra_data", data)
        // 通过上下文启动 SecondActivity
        context.startActivity(intent)
    }
}

```

```kotlin
 binding.button1.setOnClickListener {
         SecondActivity.actionStart(this, "data")
 }
```

---



## 2.UI开发

### ListView控件

1.定义 `Fruit` 类，并在 `initFruits()` 方法中构建一个包含多个水果对象的数据列表。

2在 `activity_main.xml` 中定义 ListView，接着在 `MainActivity` 的 `onCreate()` 方法中设置布局、初始化数据、获取 ListView 控件。

3.实现 `FruitAdapter` 类，通过重写 `getView()` 方法和使用 ViewHolder 模式，将数据与列表项布局（fruit_item.xml）绑定，并返回每一项的视图。

4.在 `fruit_item.xml` 中定义每个列表项的视图结构，包括图片和文本。

5.在 `MainActivity` 中创建适配器、绑定 ListView 并设置点击事件，实现用户点击列表项时显示相应水果名称的 Toast 提示。



```kotlin
class MainActivity : AppCompatActivity() {

    // 水果数据列表，用于存储水果对象
    private val fruitList = ArrayList<Fruit>()

    /**
     * Activity创建时的回调方法
     * @param savedInstanceState Activity保存的状态
     */
    override fun onCreate(savedInstanceState: Bundle?) {
        // 调用父类的onCreate方法
        super.onCreate(savedInstanceState)
        // 设置Activity的布局
        setContentView(R.layout.activity_main)
        // 初始化水果数据
        initFruits()
        // 创建适配器，将水果数据绑定到ListView
        val adapter = FruitAdapter(this, R.layout.fruit_item, fruitList)
        // 获取ListView控件
        val listView = findViewById<ListView>(R.id.listView)
        // 将适配器设置给ListView
        listView.adapter = adapter
        // 设置ListView的点击事件监听器
        listView.setOnItemClickListener { _, _, position, _ ->
            // 获取点击位置的水果
            val fruit = fruitList[position]
            // 显示水果名称的Toast消息
            Toast.makeText(this, fruit.name, Toast.LENGTH_SHORT).show()
        }
    }

    /**
     * 初始化水果数据的方法
     * 重复20次，添加三种水果（苹果、香蕉、橙子）
     */
    private fun initFruits() {
        // 重复20次，用于添加多个水果项
        repeat(20) {
            // 添加苹果
            fruitList.add(Fruit("Apple", R.drawable.b1))
            // 添加香蕉
            fruitList.add(Fruit("Banana", R.drawable.b2))
            // 添加橙子
            fruitList.add(Fruit("Orange", R.drawable.b3))
        }
    }
}
```

```kotlin
class FruitAdapter(activity: Activity, val resourceId: Int, val data: List<Fruit>) : ArrayAdapter<Fruit>(activity, resourceId, data) {

    /**
     * ViewHolder类用于缓存每个列表项中的视图，以提高列表滚动时的性能。
     */
    inner class ViewHolder(val fruitImage: ImageView, val fruitName: TextView)

    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
        val view: View
        val viewHolder: ViewHolder

        // 如果convertView为空，创建一个新的视图，否则复用convertView
        if (convertView == null) {
            // 从XML布局文件中加载视图
            view = LayoutInflater.from(context).inflate(resourceId, parent, false)
            // 初始化ImageView和TextView
            val fruitImage: ImageView = view.findViewById(R.id.fruit_image)
            val fruitName: TextView = view.findViewById(R.id.fruit_name)
            // 创建ViewHolder并绑定到view的tag中
            viewHolder = ViewHolder(fruitImage, fruitName)
            view.tag = viewHolder
        } else {
            view = convertView
            // 从convertView的tag中获取缓存的ViewHolder
            viewHolder = view.tag as ViewHolder
        }

        // 获取当前位置的Fruit对象
        val fruit = getItem(position)
        if (fruit != null) {
            // 设置水果的图片
            viewHolder.fruitImage.setImageResource(fruit.imageId)
            // 设置水果的名称
            viewHolder.fruitName.text = fruit.name
        }

        // 返回准备好的视图
        return view
    }
}

```

```kotlin
class Fruit(val name: String, val imageId: Int)
```

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <ListView
        android:id="@+id/listView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>

</LinearLayout>
```

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="60dp">

    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:layout_marginLeft="10dp"
        android:layout_gravity="center_vertical" />

    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_vertical"
        android:layout_marginLeft="10dp"
    />
</LinearLayout>
```



### RecyclerView控件

1.**添加依赖库**

2.**数据模型定义**
 `Fruit` 类定义了水果的数据结构。

3.**适配器实现**
 在 `FruitAdapter` 中：

- 定义 ViewHolder 缓存 item 内的控件；
- 在 `onCreateViewHolder` 中加载 item 布局、创建 ViewHolder 并设置点击事件；
- 在 `onBindViewHolder` 中绑定数据；
- `getItemCount` 返回数据总数。

4.**item 布局定义**
 `fruit_item.xml` 描述了每个列表项的外观（图片和名称）。

5.**MainActivity 配置**
 在 `onCreate()` 中：

- 调用 `initFruits()` 初始化数据；

- 设置 RecyclerView 的布局管理器（瀑布流效果）；

- 绑定适配器，实现数据展示。

  

```xml
implementation("androidx.recyclerview:recyclerview:1.3.2")
```

```kotlin
class MainActivity : AppCompatActivity() {

    // 定义一个 ArrayList 用于存储水果数据
    private val fruitList = ArrayList<Fruit>()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 设置当前 Activity 的布局为 activity_main.xml
        setContentView(R.layout.activity_main)

        // 初始化水果数据
        initFruits()

        // 使用 StaggeredGridLayoutManager 设置 RecyclerView 为瀑布流布局，3列垂直排列
        val layoutManager = StaggeredGridLayoutManager(3, LinearLayoutManager.VERTICAL)
        // 获取布局中的 RecyclerView 控件
        val recyclerView = findViewById<RecyclerView>(R.id.recyclerView)
        // 设置 RecyclerView 的布局管理器
        recyclerView.layoutManager = layoutManager

        // 创建自定义适配器，并传入水果数据列表
        val adapter = FruitAdapter(fruitList)
        // 将适配器设置给 RecyclerView
        recyclerView.adapter = adapter
    }

    // 初始化水果数据的方法
    private fun initFruits() {
        // 重复 50 次，每次添加三种水果数据（Apple、Banana、Orange）
        repeat(50) {
            // 添加 Apple，名称通过 getRandomLengthString() 方法随机生成长度，图片资源为 R.drawable.b1
            fruitList.add(Fruit(getRandomLengthString("Apple"), R.drawable.b1))
            // 添加 Banana，图片资源为 R.drawable.b2
            fruitList.add(Fruit(getRandomLengthString("Banana"), R.drawable.b2))
            // 添加 Orange，图片资源为 R.drawable.b3
            fruitList.add(Fruit(getRandomLengthString("Orange"), R.drawable.b3))
        }
    }

    // 根据传入的字符串随机重复生成一个新的字符串
    private fun getRandomLengthString(str: String): String {
        // 随机生成重复次数（1 到 20 之间）
        val n = (1..20).random()
        val builder = StringBuilder()
        // 重复追加字符串 n 次
        repeat(n) {
            builder.append(str)
        }
        // 返回生成的字符串
        return builder.toString()
    }
}

```

```kotlin
class Fruit(val name: String, val imageId: Int)
```

```kotlin
class FruitAdapter(val fruitList: List<Fruit>) : RecyclerView.Adapter<FruitAdapter.ViewHolder>() {

    // 内部类 ViewHolder 用于缓存 item 视图中的控件，提高滚动性能
    inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        // 获取 item 布局中的 ImageView 控件
        val fruitImage: ImageView = view.findViewById(R.id.fruit_image)
        // 获取 item 布局中的 TextView 控件
        val fruitName: TextView = view.findViewById(R.id.fruit_name)
    }

    // 创建新的 ViewHolder 时调用该方法
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        // 通过 LayoutInflater 加载 item 布局文件 fruit_item.xml
        val view = LayoutInflater.from(parent.context).inflate(R.layout.fruit_item, parent, false)
        // 创建 ViewHolder 对象，传入加载好的视图
        val viewHolder = ViewHolder(view)

        // 设置整个 item 视图的点击事件
        view.setOnClickListener {
            // 通过 adapterPosition 获取当前点击的 item 位置
            val position = viewHolder.adapterPosition
            // 根据位置从数据列表中获取对应的水果对象
            val fruit = fruitList[position]
            // 显示点击提示，提示中包含水果名称
            Toast.makeText(parent.context, "you clicked view ${fruit.name}", Toast.LENGTH_SHORT).show()
        }

        // 为 item 中的 ImageView 设置点击事件
        viewHolder.fruitImage.setOnClickListener {
            // 同样通过 adapterPosition 获取点击项的位置
            val position = viewHolder.adapterPosition
            // 根据位置获取对应的水果对象
            val fruit = fruitList[position]
            // 显示点击提示，提示中包含水果名称
            Toast.makeText(parent.context, "you clicked image ${fruit.name}", Toast.LENGTH_SHORT).show()
        }
        // 返回创建好的 ViewHolder 对象
        return viewHolder
    }

    // 将数据绑定到 ViewHolder 上时调用
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        // 根据 position 获取对应的水果对象
        val fruit = fruitList[position]
        // 设置 ImageView 显示水果的图片资源
        holder.fruitImage.setImageResource(fruit.imageId)
        // 设置 TextView 显示水果的名称
        holder.fruitName.text = fruit.name
    }

    // 返回数据列表的大小，决定 RecyclerView 的 item 个数
    override fun getItemCount() = fruitList.size
}
```

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>

</LinearLayout>
```

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="5dp">

    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:layout_gravity="center_horizontal"
        android:layout_marginTop="10dp"/>

    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="left"
        android:layout_marginTop="10dp" />

</LinearLayout>
```

---



### Fragment碎片

Fragment是一种可以嵌入在Activity的UI片段

### Fragment的简单用法

1. 写左右两个Fragment布局
2. 新建左右两个Fragment类
3. 在`activity_main`中引入两个Fragment

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="Button" />

</LinearLayout>
```

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:background="#F2CAD8"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:textSize="24sp"
        android:text="This is right fragment" />
</LinearLayout>
```

```kotlin
class LeftFragment : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.left_fragment, container, false)
    }
}
```

```kotlin
class RightFragment: Fragment() {
    companion object {
        const val TAG = "RightFragment"
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.right_fragment, container, false)
    }
}
```

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"
    android:fitsSystemWindows="true">

    <fragment
        android:id="@+id/leftFrag"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:name="com.example.fragmenttest.LeftFragment"
        tools:layout="@layout/left_fragment"/>

    <frameLayout
        android:id="@+id/rightLayout"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:name="com.example.fragmenttest.RightFragment"
        tools:layout="@layout/right_fragment"/>

</LinearLayout>
```



### 动态添加Fragment

1. 新建`another_right_fragmen`t和`AnotherRightFragment`

2. 动态添加到`activity_main`中

3. 修改`MainActivity` 

   (1) 创建待添加 Fragment 的实例。
   (2) 获取 `getSupportFragmentManager() `方法。
   (3) 开启一个事务，通过调用` beginTransaction() `方法开启。
   (4) 向容器内添加或替换 Fragment，一般使用 `replace() `方法实现，需要传入容器的 id 和待添加的 Fragment 实例。
   (5) 提交事务，调用` commit()`方法来完成。

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:background="#ffff00"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:textSize="24sp"
        android:text="This is another right fragment"/>
</LinearLayout>
```

```kotlin
class AnotherRightFragment : Fragment(){
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.another_right_fragment, container, false)
    }
}
```

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"
    android:fitsSystemWindows="true">

    <fragment
        android:id="@+id/leftFrag"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:name="com.example.fragmenttest.LeftFragment"
        tools:layout="@layout/left_fragment" />

    <FrameLayout
        android:id="@+id/rightLayout"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1">
    </FrameLayout>

</LinearLayout>
```

```kotlin
class MainActivity : AppCompatActivity() {
    
    /**
     * onCreate是Activity的生命周期回调方法，用于初始化组件和布局
     * @param savedInstanceState 如果活动是被重建，保存状态的Bundle对象，否则为null
     */
    @SuppressLint("MissingInflatedId")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 设置活动的用户界面布局
        setContentView(R.layout.activity_main)
        
        // 获取按钮控件
        val button = findViewById<Button>(R.id.button)
        
        // 设置按钮点击监听器
        button.setOnClickListener {
            // 当按钮被点击时，替换右侧布局为AnotherRightFragment
            replaceFragment(AnotherRightFragment())
        }
        
        // 初始时显示RightFragment
        replaceFragment(RightFragment())
    }
    
    /**
     * 替换右侧布局中的Fragment
     * @param fragment 要替换的Fragment实例
     */
    private fun replaceFragment(fragment: Fragment) {
        // 获取SupportFragmentManager实例
        val fragmentManager = supportFragmentManager
        // 开始一个事务，用于执行Fragment替换操作
        val fragmentTransaction = fragmentManager.beginTransaction()
        
        // 将指定的Fragment替换到右侧布局容器中
        fragmentTransaction.replace(R.id.rightLayout, fragment)
        
        // 如果替换的Fragment是AnotherRightFragment，则将其添加到回退栈中
        if (fragment is AnotherRightFragment) {
            fragmentTransaction.addToBackStack(null)
        }
        
        // 提交事务，执行Fragment替换操作
        fragmentTransaction.commit()
    }
}
```



### 在Fragment中实现返回栈

```kotlin
 val fragmentTransaction = fragmentManager.beginTransaction()
fragmentTransaction.addToBackStack(null)
```



### Fragment和Activity之间的交互

#### 1.在Activity调用Fragment

```kotlin
val fragment = leftFrag as LeftFragment
```

#### 2.在Fragment调用Activity

```kotlin
if (activity!=null) {
    val mainActivity = activity as MainActivity
}
```



### Fragment的生命周期

#### 1. onAttach(Context context)

- **作用：** 当 Fragment 被添加到 Activity 时，会首先调用该方法。这时 Fragment 与宿主 Activity 建立关联，但还没有创建自身的视图。
- **注意：** 此时你可以获取宿主 Activity 的上下文，进行一些必要的初始化工作。

#### 2. onCreate(Bundle savedInstanceState)

- **作用：** 在 Fragment 创建时调用，用于进行一些非视图相关的初始化操作，比如初始化数据、设置选项等。
- **注意：** 此阶段不适合初始化界面相关的内容，因为视图尚未创建。

#### 3. onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)

- **作用：** 用于创建并返回 Fragment 的视图层次结构（通常通过 XML 布局文件膨胀得到）。
- **注意：** 你可以在这里绑定视图，设置控件的属性或事件监听。

#### 4. onViewCreated(View view, Bundle savedInstanceState)

- **作用：** 当视图被创建后立即调用，此时可以对视图进行进一步的初始化（例如查找子视图、设置适配器等）。
- **注意：** 虽然这是可选的，但有助于将视图相关的逻辑与视图创建分离。

#### 5. onActivityCreated(Bundle savedInstanceState)

- **作用：** 当宿主 Activity 的 onCreate() 方法执行完毕后调用，这时 Fragment 的宿主 Activity 已经完全初始化，可以安全地与 Activity 进行交互。
- **注意：** 可以在此阶段恢复状态或进行依赖于 Activity 的操作。

#### 6. onStart()

- **作用：** Fragment 对用户可见。此时界面已经呈现，但还没有获得用户焦点。
- **注意：** 通常在这里开始一些较轻的 UI 刷新工作。

#### 7. onResume()

- **作用：** Fragment 进入活动状态，此时它与用户进行交互。界面完全处于前台，响应用户输入。
- **注意：** 可以在这里启动动画、开始监听传感器数据等与用户交互密切相关的操作。

#### 8. onPause()

- **作用：** 当 Fragment 失去焦点，用户无法与之交互时调用（例如，用户离开应用或启动新的 Activity）。
- **注意：** 在这里应停止可能影响性能或不必要的操作，比如暂停动画、释放资源等。

#### 9. onStop()

- **作用：** Fragment 不再对用户可见，但仍保留在内存中。
- **注意：** 此阶段可进行资源释放、停止更新 UI 等操作，确保不会浪费资源。

#### 10. onDestroyView()

- **作用：** Fragment 的视图层次结构被销毁。此时与视图相关的资源（如绑定的视图、适配器等）应当被清理。
- **注意：** 如果需要保存视图状态，可以在此方法之前进行处理。

#### 11. onDestroy()

- **作用：** Fragment 自身被销毁，用于释放所有剩余资源和进行最终清理工作。
- **注意：** 此阶段与 onCreate() 相对，用于做一些彻底的清理工作。

#### 12. onDetach()

- **作用：** Fragment 与宿主 Activity 的关联被断开，生命周期结束。
- **注意：** 此时所有与 Activity 相关的引用都应该被释放，以防止内存泄漏

---



## 3.广播(Broadcast)

广播机制（Broadcasting）指的是将消息、数据或信号从一个源同时发送给网络中所有或一部分节点或设备。它与单播（Unicast，一对一通信）和多播（Multicast，一对多通信）不同，广播主要面向整个网络或一个较大的受众群体。

### 1. 标准广播

**定义与特点**

- **无序性**：标准广播在消息传输时不对接收顺序做严格保证。不同接收者收到消息的顺序可能不一致，这种特性使其实现相对简单。
- **高效性**：由于不需要额外的排序和同步机制，标准广播通常具有较低的延时和较高的传输效率。
- 适用场景：
  - 用于事件通知、状态更新或日志广播等场景，这些场景对消息顺序没有严格要求。
  - 在对实时性要求高、能够容忍一定顺序差异的应用中，标准广播是常用的选择。

------

### 2. 有序广播

**定义与特点**

- **顺序一致性**：有序广播要求所有接收者必须按照相同的顺序接收到所有消息。也就是说，无论消息是从哪个节点发送，所有节点在消息的交付顺序上都必须保持一致。
- **实现复杂性**：为了确保全局顺序一致，常需要采用额外的排序机制或共识算法（如逻辑时钟、矢量时钟或专门的总排序服务）。这种机制虽然能够确保系统状态的一致性，但同时也会增加系统的复杂性和延时。
- 适用场景：
  - 在需要高度一致性的分布式系统中，如分布式数据库复制、一致性协议、金融交易系统等，保证操作顺序一致是关键。
  - 有序广播有助于防止由于消息乱序而引发的数据冲突或状态不一致问题，从而提高系统的容错性和数据一致性。

------

### 3. 对比与选择

| 特性         | 标准广播                     | 有序广播                           |
| ------------ | ---------------------------- | ---------------------------------- |
| **消息顺序** | 无严格顺序保证               | 全局顺序一致                       |
| **实现难度** | 实现简单，效率高             | 需要额外排序/同步机制，复杂度高    |
| **延时**     | 较低                         | 可能因排序/同步而增加延时          |
| **适用场景** | 实时性要求高、顺序要求不严格 | 状态一致性要求高、需要全局顺序一致 |

---

### 4 静态注册广播

**定义**
 静态注册广播是在系统配置或设计阶段就预先确定好所有参与广播的节点，广播目标在系统运行过程中保持不变。

**特点与优势**

- **实现简单**：广播目标在配置文件或代码中硬编码，开发和调试过程中较为直接。
- **低开销**：无需额外的注册和管理机制，消息直接发送给预定的目标。
- **确定性高**：由于广播组成员固定，网络拓扑和消息传递路径相对固定，有助于预期性能分析。

**局限性**

- **灵活性不足**：如果系统中的节点发生增减或迁移，必须手动更新配置，无法自动适应环境变化。
- **扩展性受限**：适用于节点较少且变化不频繁的系统，对于大规模动态环境来说不够高效。

------

### 5. 动态注册广播

**定义**
 动态注册广播允许系统中节点在运行时主动注册成为广播组成员或退出广播组。此类机制通常依赖一个注册中心或服务发现模块，实时维护当前可用的广播目标列表。

**特点与优势**

- **高灵活性**：节点上线、下线、扩容或故障恢复时，注册中心会自动更新广播组成员，保证广播消息能够覆盖最新的系统状态。
- **自动管理**：利用心跳检测或健康检查机制，动态剔除不可用节点，提升系统整体的容错能力。
- **便于扩展**：适合大规模、动态变化频繁的分布式系统，能够根据实际负载和环境变化自动调整广播对象。

**局限性**

- **实现复杂**：需要部署和维护额外的注册服务，涉及网络延时、状态一致性等问题。
- **管理开销**：动态更新广播组可能带来短暂的不一致或额外的网络通信开销，需仔细设计以减少延迟和资源消耗。

------

### 6. 对比与适用场景

| 特性               | 静态注册广播                                   | 动态注册广播                                     |
| ------------------ | ---------------------------------------------- | ------------------------------------------------ |
| **注册方式**       | 在配置阶段固定节点列表                         | 节点可在运行时自动注册或注销                     |
| **实现复杂度**     | 实现简单，依赖硬编码或配置文件                 | 需要额外的注册中心和健康检查机制                 |
| **灵活性与扩展性** | 节点变化需要人工干预，适合节点稳定的小规模系统 | 适应节点频繁变动，大规模系统中自动维护广播组成员 |
| **系统管理开销**   | 管理和维护简单，但缺乏自动适应性               | 运维自动化，但引入额外通信和状态同步的开销       |



### 动态注册监听时间变化(记得取消注册)

1. 新建一个类继承自`BroadcastReceiver`

2. 重写`onReceiver()`方法,执行具体逻辑

   ```kotlin
   class MainActivity : AppCompatActivity() {
       lateinit var timeChangeReceiver: TimeChangeReceiver
       @SuppressLint("WrongViewCast")
       override fun onCreate(savedInstanceState: Bundle?) {
           super.onCreate(savedInstanceState)
           setContentView(R.layout.activity_main)
           val intentFilter = IntentFilter()
           intentFilter.addAction("android.intent.action.TIME_TICK")
           timeChangeReceiver = TimeChangeReceiver()
           registerReceiver(timeChangeReceiver, intentFilter)
       }
       override fun onDestroy() {
           super.onDestroy()
           unregisterReceiver(timeChangeReceiver) //取消注册
       }
       inner class TimeChangeReceiver : BroadcastReceiver() {
           override fun onReceive(context: Context, intent: Intent) {
               Toast.makeText(context, "Time has changed", Toast.LENGTH_SHORT).show()
           }
       }
   }
   ```

   

### 静态注册实现开机启动

1. 用快捷方式创建一个广播接收器
2. 在`AndroidManifest`添加对应权限与`action`

```kotlin
class BootCompleteReceiver : BroadcastReceiver() {

    override fun onReceive(context: Context, intent: Intent) {
        Toast.makeText(context, "Boot Complete", Toast.LENGTH_SHORT).show()
    }
}
```

```xml
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />

<receiver
            android:name=".BootCompleteReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>
```



### 发送标准广播

1. 定义一个广播接收器
2. 在AndroidManifest添加自定义广播
3. 在MainActivity发送广播

```kotlin
class MyBroadcastReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        Toast.makeText(context, "received in MyBroadcastReceiver", Toast.LENGTH_SHORT).show()
        abortBroadcast()
    }
}
```

```xml
<receiver
            android:name=".MyBroadcastReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter android:priority="100">
                <action android:name="com.example.broadcasttest.MY_BROADCAST" />
            </intent-filter>
        </receiver>
```

```kotlin
val button = findViewById<androidx.appcompat.widget.AppCompatButton>(R.id.button)
        button.setOnClickListener {
            val intent = Intent("com.example.broadcasttest.MY_BROADCAST")
            intent.setPackage(packageName)
            sendOrderedBroadcast(intent, null)
        }
```



### 发送有序广播

1. 新建`AnotherBroadcastReceiver`
2. 在AndroidManifest添加自定义广播
3. 在`MainActivity`利用`sendOrderedBroadcast`发送广播
4. 在AndroidManifest设置优先级
5. 在`MyBroadcastReceiver`利用`abortBroadcast`截断广播

```kotlin
class AnotherBroadcastReceiver : BroadcastReceiver() {

    override fun onReceive(context: Context, intent: Intent) {
        Toast.makeText(context, "received in AnotherBroadcastReceiver", Toast.LENGTH_SHORT).show()
    }
}
```

```xml
<receiver
            android:name=".AnotherBroadcastReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter>
                <action android:name="com.example.broadcasttest.MY_BROADCAST" />
            </intent-filter>
        </receiver>
```

```kotlin
val button = findViewById<androidx.appcompat.widget.AppCompatButton>(R.id.button)
        button.setOnClickListener {
            val intent = Intent("com.example.broadcasttest.MY_BROADCAST")
            intent.setPackage(packageName)
            sendOrderedBroadcast(intent, null)
        }
```

```xml
<intent-filter android:priority="100">
                <action android:name="com.example.broadcasttest.MY_BROADCAST" />
            </intent-filter>
```

```kotlin
class MyBroadcastReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        Toast.makeText(context, "received in MyBroadcastReceiver", Toast.LENGTH_SHORT).show()
        abortBroadcast()
    }
}
```

---



## 4.持久化技术

数据持久化技术就是指将那些内存中的瞬时数据保存到存储设备中,保证即使在手机或计算机关机的情况下,这些数据仍然不会消失.

### 1.文件存储

1. 新建`save`函数,通过`openFileOutput()`方法存入数据
2. 让Activity在`Destroy`之前掉用`save`方法
3. 在`load`中通过`openFileInput`读取数据

```kotlin
class MainActivity : AppCompatActivity() {
    
    // Activity创建时的回调方法
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // 从文件中加载数据
        val inputText = load()
        
        // 如果加载的文字不是空的，则将其显示在EditText中
        if (inputText.isNotEmpty()) {
            val editText = findViewById<EditText>(R.id.editText)
            editText.setText(inputText)
            editText.setSelection(inputText.length)
            
            // 显示一个toast提示，表示数据已恢复
            Toast.makeText(this, "Restoring saved data", Toast.LENGTH_SHORT).show()
        }
    }

    /**
     * 从文件中加载数据的方法
     * @return 返回加载的字符串内容，如果出错则返回空字符串
     */
    private fun load(): String {
        val content = StringBuilder()
        try {
            // 打开文件输入流，文件名为“data”
            val input = openFileInput("data")
            // 创建缓冲读取器
            val reader = BufferedReader(InputStreamReader(input))
            
            // 使用reader.forEachLine读取每一行内容并追加到content中
            reader.use {
                reader.forEachLine {
                    content.append(it)
                }
            }
        } catch (e: Exception) {
            // 如果出错，打印异常堆栈信息
            e.printStackTrace()
        }
        // 返回读取到的内容
        return content.toString()
    }

    // Activity被销毁时的回调方法
    override fun onDestroy() {
        super.onDestroy()
        
        // 获取EditText实例
        val editText = findViewById<EditText>(R.id.editText)
        // 获取EditText中的文字内容
        val inputText = editText.text.toString()
        
        // 调用save方法保存内容
        save(inputText)
    }

    /**
     * 将输入的文字内容保存到文件中的方法
     * @param inputText 需要保存的字符串内容
     */
    private fun save(inputText: String) {
        try {
            // 打开文件输出流，文件名为“data”，模式为私有（只有本应用可以访问）
            val output = openFileOutput("data", MODE_PRIVATE)
            // 创建缓冲写入器
            val writer = BufferedWriter(OutputStreamWriter(output))
            
            // 使用writer写入内容
            writer.use {
                it.write(inputText)
            }
        } catch (e: Exception) {
            // 如果出错，打印异常堆栈信息
            e.printStackTrace()
        }
    }
}

```



### 2.SharedPreferences存储

1. 通过`getSharedPreferences()`指定文件名并得到`SharedPreferences.Editor`对象
2. 添加新数据,用`apple()`进行提交
3. 运用一系列`get`方法提取数据

```kotlin
class MainActivity : AppCompatActivity() {
    // 用于日志记录的标签，标识这个类的日志信息
    private val TAG = "MainActivity"

    // Activity创建时的回调方法
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 设置主界面为activity_main布局
        setContentView(R.layout.activity_main)

        // 获取保存按钮实例
        val saveButton = findViewById<Button>(R.id.saveButton)
        // 获取恢复按钮实例
        val restoreButton = findViewById<Button>(R.id.restoreButton)

        // 设置保存按钮的点击事件监听器
        saveButton.setOnClickListener {
            // 获取SharedPreferences的编辑器，文件名为"sharedPreferences"，模式为私有（仅本应用访问）
            val editor = getSharedPreferences("sharedPreferences", MODE_PRIVATE).edit()
            
            // 保存字符串类型的数据，键为"name"，值为"John Doe"
            editor.putString("name", "John Doe")
            // 保存整数类型的数据，键为"age"，值为30
            editor.putInt("age", 30)
            // 保存布尔类型的数据，键为"isStudent"，值为true
            editor.putBoolean("isStudent", true)
            
            // 提交修改，保存数据到SharedPreferences文件中
            editor.apply()
        }

        // 设置恢复按钮的点击事件监听器
        restoreButton.setOnClickListener {
            // 获取SharedPreferences文件，文件名为"data"，模式为私有（仅本应用访问）
            val sharedPreferences = getSharedPreferences("data", Context.MODE_PRIVATE)
            
            // 读取字符串类型的数据，键为"name"，默认值为空字符串
            val name = sharedPreferences.getString("name", "")
            // 读取整数类型的数据，键为"age"，默认值为0
            val age = sharedPreferences.getInt("age", 0)
            // 读取布尔类型的数据，键为"isStudent"，默认值为false
            val isStudent = sharedPreferences.getBoolean("isStudent", false)

            // 打印日志，显示读取的数据
            Log.d(TAG, "name is $name")
            Log.d(TAG, "age is $age")
            Log.d(TAG, "isStudent is $isStudent")
        }
    }
}

```



### SQLite数据库存储

SQLite是一个轻量级的关系型数据库，嵌入在Android系统中，适合存储结构化数据。与传统的客户端-服务器数据库不同，SQLite是一个内嵌式数据库，所有的数据操作都是在本地进行，非常适合需要离线存储的小型或中型数据应用。

1. 通过SOL语句建表,在`onCreate`方法里面调用`db.execSQL()`创建数据库
2. 在`onUpgrade()`执行DROP语句对数据库进行更新
3. 增加数据库帮助类的版本号

```kotlin
class MainActivity : AppCompatActivity() {
    @SuppressLint("MissingInflatedId", "Range")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 设置主界面为activity_main布局
        setContentView(R.layout.activity_main)
        
        // 获取创建数据库按钮实例
        val createDatabase = findViewById<Button>(R.id.createDatabase)
        // 初始化数据库帮助类，参数依次为上下文、数据库名、版本号
        val dbHelper = MyDatabaseHelper(this, "BookStore.db", 2)
        
        // 设置创建数据库按钮的点击事件监听器
        createDatabase.setOnClickListener {
            // 获取可写的数据库实例，确保数据库和表被创建
            dbHelper.writableDatabase
        }
        
        // 获取添加数据按钮实例
        val addDate = findViewById<Button>(R.id.addData)
        // 设置添加数据按钮的点击事件监听器
        addDate.setOnClickListener {
            // 获取可写的数据库实例
            val db = dbHelper.writableDatabase
            
            // 准备要插入的数据1
            val values1 = ContentValues().apply {
                put("name", "The Da Vinci Code")
                put("author", "Dan Brown")
                put("pages", 454)
                put("price", 16.96)
            }
            // 将数据插入到"Book"表中，返回新行的ID
            db.insert("Book", null, values1)
            
            // 准备要插入的数据2
            val values2 = ContentValues().apply {
                put("name", "The Lost Symbol")
                put("author", "Dan Brown")
                put("pages", 510)
                put("price", 19.95)
            }
            // 将数据插入到"Book"表中，返回新行的ID
            db.insert("Book", null, values2)
        }
        
        // 获取更新数据按钮实例
        val updateData = findViewById<Button>(R.id.updateData)
        // 设置更新数据按钮的点击事件监听器
        updateData.setOnClickListener {
            // 获取可写的数据库实例
            val db = dbHelper.writableDatabase
            
            // 准备要更新的数据
            val values = ContentValues()
            values.put("price", 10.99)
            
            // 更新"Book"表中满足条件的记录
            // 条件：name等于"The Da Vinci Code"
            db.update("Book", values, "name = ?", arrayOf("The Da Vinci Code"))
        }
        
        // 获取删除数据按钮实例
        val deleteData = findViewById<Button>(R.id.deleteData)
        // 设置删除数据按钮的点击事件监听器
        deleteData.setOnClickListener {
            // 获取可写的数据库实例
            val db = dbHelper.writableDatabase
            
            // 删除"Book"表中满足条件的记录
            // 条件：pages大于500
            db.delete("Book", "pages > ?", arrayOf("500"))
        }
        
        // 获取查询数据按钮实例
        val queryData = findViewById<Button>(R.id.queryData)
        // 设置查询数据按钮的点击事件监听器
        queryData.setOnClickListener {
            // 获取可写的数据库实例
            val db = dbHelper.writableDatabase
            
            // 查询"Book"表中的所有数据
            val cursor = db.query("Book", null, null, null, null, null, null)
            
            // 遍历查询结果
            if (cursor.moveToFirst()) {
                do {
                    // 获取每一列的数据
                    val name = cursor.getString(cursor.getColumnIndex("name"))
                    val author = cursor.getString(cursor.getColumnIndex("author"))
                    val pages = cursor.getInt(cursor.getColumnIndex("pages"))
                    val price = cursor.getDouble(cursor.getColumnIndex("price"))
                    
                    // 打印日志，显示查询到的数据
                    println("name is $name, author is $author, pages is $pages, price is $price")
                } while (cursor.moveToNext())
            }
            
            // 关闭游标，释放资源
            cursor.close()
        }
        
        // 获取替换数据按钮实例
        val replaceData = findViewById<Button>(R.id.replaceData)
        // 设置替换数据按钮的点击事件监听器
        replaceData.setOnClickListener {
            // 获取可写的数据库实例
            val db = dbHelper.writableDatabase
            
            // 开始一个事务
            db.beginTransaction()
            try {
                // 删除"Book"表中的所有记录
                db.delete("Book", null, null)
                
                // 这里可以手动抛出异常进行事务回滚测试
                // if (true) {
                //     throw NullPointerException()
                // }
                
                // 准备要插入的数据
                val values = ContentValues().apply {
                    put("name", "Game of Thrones")
                    put("author", "George Martin")
                    put("pages", 720)
                    put("price", 20.85)
                }
                
                // 将数据插入到"Book"表中
                db.insert("Book", null, values)
                
                // 标记事务为成功
                db.setTransactionSuccessful()
            } catch (e: Exception) {
                // 捕获异常并打印异常信息
                e.printStackTrace()
            } finally {
                // 结束事务
                db.endTransaction()
            }
        }
    }
}

```



#### 1. 添加（插入）数据

**核心步骤**

- 获取数据库实例（通常使用`writableDatabase`）。
- 使用`ContentValues`封装待插入的数据。
- 调用`insert()`方法将数据插入表中，并返回新记录的ID。

```kotlin
fun insertCity(dbHelper: DBHelper, name: String, code: String) {
    // 获取可写数据库
    val db = dbHelper.writableDatabase
    // 使用ContentValues封装要插入的数据
    val values = ContentValues().apply {
        put("name", name)
        put("code", code)
    }
    // 调用insert方法，将数据插入City表
    val newRowId = db.insert("City", null, values)
    // 判断插入是否成功
    if (newRowId != -1L) {
        println("插入成功，Row ID: $newRowId")
    } else {
        println("插入失败")
    }
    // 操作结束后关闭数据库
    db.close()
}
```

**注意事项**

- 插入操作一般要在子线程中执行，避免阻塞主线程。可以使用Kotlin协程或其它异步处理方式。
- 可以通过事务优化批量插入的性能。



#### 2. 更新数据

**核心步骤**

- 获取数据库实例（使用`writableDatabase`）。
- 构造一个`ContentValues`对象来表示要更新的字段及其新值。
- 使用`update()`方法，传入更新条件和条件参数。

```kotlin
fun updateCityName(dbHelper: DBHelper, cityId: Int, newName: String) {
    val db = dbHelper.writableDatabase
    // 构造ContentValues更新记录
    val values = ContentValues().apply {
        put("name", newName)
    }
    // 构造更新条件
    val selection = "id = ?"
    val selectionArgs = arrayOf(cityId.toString())
    // 调用update方法更新数据
    val count = db.update("City", values, selection, selectionArgs)
    println("更新了$count条记录")
    db.close()
}
```

**注意事项**

- 更新操作需要谨慎构造条件（WHERE子句），避免误更新多条记录。
- 同样建议在子线程中执行更新操作以避免主线程阻塞。



#### 3. 删除数据

**核心步骤**

- 获取可写数据库实例。
- 构造删除条件（WHERE子句）及其参数。
- 调用`delete()`方法删除记录。

```kotlin
fun deleteCity(dbHelper: DBHelper, cityId: Int) {
    val db = dbHelper.writableDatabase
    // 构造删除条件
    val selection = "id = ?"
    val selectionArgs = arrayOf(cityId.toString())
    // 调用delete方法删除记录
    val deletedRows = db.delete("City", selection, selectionArgs)
    println("删除了$deletedRows条记录")
    db.close()
}
```

**注意事项**

- 删除数据时一定要构造准确的删除条件，避免误删数据。
- 如需删除所有数据，可以传入`null`作为条件，但要慎重使用。



#### 4. 查询数据

**核心步骤**

- 获取数据库实例（通常使用`readableDatabase`）。
- 构造要查询的列数组、WHERE条件（可选）以及排序等参数。
- 调用`query()`方法或者使用`rawQuery()`执行SQL语句。
- 使用`Cursor`遍历查询结果，并通过`getColumnIndexOrThrow`获取列数据。

```kotlin
fun queryCities(dbHelper: DBHelper): List<Triple<Int, String, String>> {
    val db = dbHelper.readableDatabase
    // 指定要返回的列
    val projection = arrayOf("id", "name", "code")
    // 查询City表中的所有数据
    val cursor: Cursor = db.query(
        "City",        // 表名
        projection,    // 返回的列
        null,          // WHERE子句
        null,          // WHERE参数
        null,          // GROUP BY子句
        null,          // HAVING子句
        "id ASC"       // ORDER BY子句：按id升序排列
    )
    // 存储查询结果的集合
    val cities = mutableListOf<Triple<Int, String, String>>()
    with(cursor) {
        while (moveToNext()) {
            // 根据列名获取数据
            val id = getInt(getColumnIndexOrThrow("id"))
            val name = getString(getColumnIndexOrThrow("name"))
            val code = getString(getColumnIndexOrThrow("code"))
            cities.add(Triple(id, name, code))
        }
        close()  // 用完Cursor后关闭，防止内存泄漏
    }
    db.close()
    return cities
}
```

**注意事项**

- 查询操作后要及时关闭`Cursor`和数据库。
- 当需要查询大量数据时，可考虑使用分页查询以提高性能。
- 对于复杂查询，可以使用`rawQuery()`方法执行自定义的SQL语句。



#### 5. 事务

1. **开启事务**：调用`beginTransaction()`开始一个事务。
2. **执行数据库操作**：在事务中执行多条数据库操作（如插入、更新等）。
3. **标记事务成功**：当所有操作执行成功后，调用`setTransactionSuccessful()`标记事务成功。如果没有调用这一方法，后续`endTransaction()`时将会回滚事务。
4. **结束事务**：调用`endTransaction()`结束事务。如果事务成功，则提交所有操作，否则回滚所有操作。

```kotlin
fun insertMultipleCities(dbHelper: DBHelper, cities: List<Pair<String, String>>) {
    val db = dbHelper.writableDatabase
    // 开始事务
    db.beginTransaction()
    try {
        cities.forEach { city ->
            val values = ContentValues().apply {
                put("name", city.first)
                put("code", city.second)
            }
            db.insert("City", null, values)
        }
        // 标记事务成功
        db.setTransactionSuccessful()
        println("批量插入成功")
    } catch (e: Exception) {
        e.printStackTrace()
        println("批量插入失败，事务回滚")
    } finally {
        // 结束事务，如果未调用setTransactionSuccessful，则会自动回滚
        db.endTransaction()
        db.close()
    }
}
```

---

